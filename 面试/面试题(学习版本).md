## 平时如何进行学习的

## 目前在学习什么

## [列举一下移动端适配方案](https://www.jianshu.com/p/2c33921d5a68)

### rem

**rem**是相对长度单位，rem方案中的样式设计为相对于**根元素**`font-size`计算值的倍数。根据 **屏幕宽度** 设置`html`标签的`font-size`，在布局时使用 **rem** 单位布局，达到自适应的目的，是 **弹性布局** 的一种实现方式。

**实现过程：**  首先获取文档根元素和设备`dpr`，设置 **rem**，在`html`文档加载和解析完成后调整`body`字体大小； 在页面**缩放 / 回退 / 前进**的时候， 获取元素的内部宽度 (不包括垂直滚动条，边框和外边距)，重新调整 **rem** 大小。

### vh/vw方案

#### 原理

**视口**是浏览器中用于呈现网页的区域，移动端的视口通常指的是 **布局视口**

- **vw** : **1vw** 等于 **视口宽度** 的 **1%**
- **vh** : **1vh**  等于 **视口高度** 的 **1% **
- **vmin** : 选取 **vw** 和 **vh** 中 **最小** 的那个
- **vmax** : 选取 **vw** 和 **vh** 中 **最大** 的那个

### 基于媒体查询的响应式设计

## 内存泄露

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **闭包**: 会导致父级中的变量无法被释放
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

## 状态码304: 资源未修改，可使用缓存

讲一下协商缓存 强缓存

## JavaScript

### js基础

#### 引用类型

##### 基本包装类型

ECMAScript提供了三个基本包装类型：`Boolean、Number、String`。

实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能过调用一些方法来操作这些数据。

引用类型与基本包装类型的区别在于**对象的生存期**：使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁。这意味着我们**不能在运行时为基本类型值添加属性**

包装对象 : 就是当基本类型以对象的方式去使用时，*JavaScript* 会转换成对应的包装类型，相当于 ***new*** 一个对象，内容和基本类型的内容一样，然后当操作完成再去访问的时候，这个临时对象会被销毁，然后再访问时候就是 ***undefined***

```js
var str = 'hello';
str.number = 10; //假设我们想给字符串添加一个属性 number ，底层会有如下步骤
(
    var _str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象
    _str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存
    _str =null; // 3 这个对象又被销毁
)
console.log(str.number); // undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤
(
   var str = new String('hello');// 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为 hello 对象
   str.number = undefined;// 2 因为包装对象下面没有 number 这个属性，所以又会重新添加，因为没有值，所以值是未定义;然后弹出结果
   str =null; // 3 这个对象又被销毁
)
```

#### 变量

var、let、const是JavaScript声明变量的三种方式，其中let和const是ES6为JavaScript新增的两种方式，用法与var类似。曾经问到它们三者之间的区别时，答案之一就有let和const不存在变量提升。但是经过一番调查研究，发现这个答案并不是那么准确。

##### 变量提升

众所周知，var命令会发生**变量提升**的现象，即变量可以在声明前使用：

```javascript
console.log(a); // undefined
var a = 1;
```

这种现象还是很奇怪的，因为按照正常的逻辑，变量应该在声明语句之后才可以使用。其实，JavaScript与其他语言一样，都需要经历编译和执行阶段。但JavaScript编译器在编译阶段会搜集所有的变量声明，并将**变量声明**提前到变量**当前所在作用域**的顶部，也就是说，变量声明在编译阶段已经执行，而赋值则在执行阶段执行到对应语句时才会执行。所以才会出现所谓的“变量提升”。上面代码等价于：  

```javascript
var a;
console.log(a); // undefined
a = 1;
```

为什么要强调当前呢？因为ES5分为全局作用域和函数作用域，不同作用域中同名变量互不影响。例如：

```javascript
console.log(b); // ReferenceError: b is not defined
function foo () {
    console.log(b); // undefined
    var b = 1;
}
foo()
```

当代码执行时，在函数作用域内的变量b会被提升到当前作用域的顶部，也就是foo函数内的顶部，而不是整体代码的顶部，所以函数内输出undefined，而函数外部不存在变量b，所以会报ReferenceError错误。  

**隐式全局变量不会被提升**：

```JavaScript
function foo () {
    console.log(b) // ReferenceError
    b = 1
    console.log(b) // 1
}
foo()
console.log(b) // 1
```

使用var声明变量，在函数内部是局部变量，在函数外部是全局变量，没有使用var声明的变量，在函数内部或外部都是全局变量，但如果是在函数内部声明，也叫隐式全局变量，在函数外部使用之前需要先调用方法，告知系统声明了全局变量后方可在函数外部使用。  

另外，**函数声明也会提升**：

```javascript
foo(); // 1
function foo () {
    console.log(1)
}
```

**函数表达式不会被提升**

```javascript
foo(); // TypeError: foo is not a function
var foo = function () {
    console.log(1)
}
```

这是因为JavaScript编译器会在编译阶段**优先读取函数声明的代码，以确保函数能够被引用到**；而对于函数表达式，只有在执行到相应的语句时才进行解析。也可以这么理解，上述代码相当于声明了一个变量foo，然后把函数赋值给变量foo，而变量提升在最开始也说过是将变量的声明提升到顶部，赋值代码留在原地，所以函数表达式不会被提升。等价于：

```javascript
var foo;
foo();
foo = function () {
    console.log(1)
}
```

**函数提升会优先于变量提升**

```javascript
console.log(foo); // [Function: foo]
var foo = 10;
function foo () {}
```

上述代码等价于：

```javascript
function foo () {}
var foo;
console.log(foo);
foo = 10;
```

同名函数和变量为什么没有被覆盖呢？  

这是因为对于同名的变量声明，Javascript采用的是忽略原则，后声明的会被忽略。对于同名的函数声明，Javascript采用的是覆盖原则，先声明的会被覆盖。对于同名的函数声明和变量声明，采用的是忽略原则，为了确保函数能够被引用到，在提升时函数声明会提升到变量声明之前，变量声明会被忽略，但是变量赋值以后会被覆盖。  

同名变量：

```javascript
//解析前
var a = 1;
var a =2;
// 解析后
var a;
var a; // 被忽略
a = 1;
a = 2;
```

同名函数:

```javascript
function foo () {
    console.log(1)
}
function foo () { // 覆盖前一个
    console.log(2)
}
foo(); // 2
```

同名函数和变量：

```javascript
// 解析前
console.log(foo); // [Function: foo]
var foo = 10;
function foo () {}
console.log(foo); // 10
// 解析后
function foo () {}
var foo; // 被忽略
console.log(foo);
foo = 10;
console.log(foo); //10
```

##### let和const

ES6中，为了纠正“**变量提升**”这一奇怪现象，let和const改变了语法行为，let和const所声明的变量必须要在**声明后**使用，否则便会报错：

```javascript
console.log(a); // ReferenceError
let a = 1;
```

另外，let和const实际上为JavaScript新增了块级作用域的概念。通过let或const声明的变量只能在命令所在的代码块内有效。

```javascript
let a = 1;
if (true) {
    a = 2; // ReferenceError;
    let a = 3;
}
```

在上述代码中，虽然if代码块外存在变量a，但是if代码块内let有声明了一个变量a，导致变量a被绑定在这个块级作用域内，不受外部的影响，所以在if代码块内部let声明前使用就会报错。同时，虽然**let和const在相同作用域下不允许重复声明**，但是由于块级作用域的存在，内层作用域不受外层作用域的影响，所以在**不同作用域**下可以定义同名变量。

##### let和const存在变量提升么？

弄明白了前两个大概念以后，正式来看看这个问题，通过**标题2**中的例子可以看出，在let声明变量前使用该变量，会抛出ReferenceError的错误，那么就说明let和const不会被提升么？  

其实，let和const是会被提升的，准确的说是**创建被提升了，但是初始化没有被提升**。  

根据ECMA-262中13.3.1的NOTE中所述：`let and const declarations define variables that are scoped to the running execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated.`  

这段话的大概意思就是let和const定义了变量执行的词法环境，**变量会在这个环境实例化时被创建，但是在变量的词法绑定之前不允许以任何方式对其进行访问**......如果let声明的变量初始化时没有词法绑定，则分配一个未定义的值undefined，同时MDN上关于let介绍中也说到` var 和 let 的不同之处在于后者是在编译时才初始化`。（词法环境应该是指上下文环境，而词法绑定应该就是赋值操作。）

也就说可以这么理解，**let声明变量分为三部分：1.创建，2.初始化，3.赋值。** 创建环节在当前环境实例化时完成。而通过**const命令声明的是一个常量，一旦声明，常量的值（内存地址不能改变）就不能改变**  ，所以const声明必须立即进行初始化，不能留到以后赋值，所以**const声明变量分为两部分：1.创建，2.初始化**，没有赋值操作，相当于把初始化赋值整合成了一步，在初始化的时候进行赋值。  

##### 总结：

根据上述ECMA-262中13.3.1和MDN文档还有**标题1**中所讲，通过var声明的变量，变量提升时相当于把创建和初始化进行了提升，没有提升赋值操作，可以理解为**var命令声明变量其实为两部分：第一部分创建的同时进行初始化，第二部分赋值。**  所以**标题1**中的代码会输出undefined：

```javascript
// 通过var声明的变量，创建和初始化都进行提升，不提升赋值操作，所以被提升后初始化为undefined
console.log(a); // undefined
var a = 1;
```

而**let和const仅仅提升了变量的创建**，初始化及赋值操作都没有进行提升

```javascript
if (true) {
    a = 2; // ReferenceError;  
    let a = 3; 
}
```

为了理解方便，可以将上述代码拆分成如下几步：

```javascript
if (true) {
    // 此时a的创建已经被提升到了if代码块内的顶部
    a = 2; // ReferenceError;  //此时对a进行赋值，由于a仅仅被创建，还没有初始化，所以会报错，a is not defined
    let a； // 完成a的初始化，根据ECMA-262 此时a为undefined
    a = 3; // 完成对a的赋值操作。
}
```

而let从创建被提升到初始化这中间的部分，就是我们平常所说的**暂时性死区(TDZ)**，即在使用let命令声明变量初始化之前，该变量都是不可用的。

```javascript
if (true) {
    // a的创建被提升，TDZ的开始
    a = 2; // ReferenceError;  
    let a； // 完成a的初始化，TDZ的结束
    a = 3; // 完成对a的赋值操作。
}
```

### 类型转换

类型转换可以分为两种，**隐性转换**和**显性转换**

#### 显性转换

主要分为三大类：数值类型、字符串类型、布尔类型

> 三大类的原始类型值的转换规则我就不一一列举了，更多详情文章链接👉[juejin.cn/post/695617…](https://juejin.cn/post/6956170676327677966)

数值类型（引用类型转换）

```js
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5

第一步，调用对象自身的`valueOf`方法。如果返回原始类型的值，则直接对该值使用`Number`函数，不再进行后续步骤。

第二步，如果`valueOf`方法返回的还是对象，则改为调用对象自身的`toString`方法。如果`toString`方法返回原始类型的值，
则对该值使用`Number`函数，不再进行后续步骤。

第三步，如果`toString`方法返回的是对象，就报错。

补充一点：`valueOf`和`toString`方法，都是可以自定义的
复制代码
```

#### 字符串类型（引用类型转换）

```js
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"

`String`方法背后的转换规则，与`Number`方法基本相同，只是互换了`valueOf`方法和`toString`方法的执行顺序。
```

#### 隐性转换

| 类型      | 转换前    | 转换后 |
| --------- | --------- | ------ |
| number    | 4         | 4      |
| string    | "1"       | 1      |
| string    | ""        | 0      |
| boolean   | true      | 1      |
| boolean   | false     | 0      |
| undefined | undefined | NaN    |
| null      | null      | 0      |

**详情看上方[👆文章链接](https://juejin.cn/post/6956170676327677966)**

### [虚拟DOM](./面试题抽离/虚拟DOM/readme.md)（点击跳转）

## TypeScript

### type和interface的区别

不同点

1. 继承 interface是通过extends实现的，type是通过&实现的。
2. type可以定义 基本类型的别名，如 type myString = string
3. type可以通过 typeof 操作符来定义，如 type myType = typeof someObj
4. type可以申明 联合类型，如 type unionType = myType1 | myType2
5. type可以申明 元组类型，如 type yuanzu = [myType1, myType2]
6. interface可以 **声明合并**   如果是type的话，就会报 **重复定义** 的警告

```tsx
interface test {
    name: string
}
 
interface test {
    age: number
}

```



## Vue

### input双向事件绑定 v-model 的实现原理

答案：通过 input 元素的 value = this.name

绑定 input 事件 this.name = $event.target.value

data 更新触发 re-render

### [vue中8种组件通信方式,](https://juejin.cn/post/6844903887162310669)

props  emit

$children $parent

provide inject

ref refs

eventBus

Vuex

$attrs $listeners

### Ajax 请求应该放在哪个生命周期

在created的时候，视图中的dom并没有被渲染出来，所以此时如果直接去操作dom节点，无法找到相关元素。
在mounted中，由于此时的dom元素已经渲染出来了，所以可以直接使用dom节点。

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

### 何时需要使用 beforeDestroy？

答案：

- 解除自定义事件 event.$off
- 清除定时器
- 解绑自定义的 DOM 事件，如 window scroll等

### vuex需要注意的点

### vuex 中 action 和 mutation有何区别？

答案：

- action 中处理异步，mutation 不可以
- mutation 做原子操作
- action 可以整合多个 mutation

### 多个组件有相同逻辑，如何抽离？

答案： 用 mixin, mixin 的一些缺点

mixin 的用法：；定义一个 js文件将export default 中的共有内容写到里面，然后在组件中import，放到 mixin数组中

mixin 的一些缺点：

1. 变量来源不明，不利于阅读。我们希望编程红的变量和方法是可查找的，但是 mixin 引入的内容编辑是不可寻找
2. 多mixin 可能造成命名冲突
3. 迷信和组件可能出现多对多的关系（一个组件引用多个 mixin, 一个mixin被多个组件引用），复杂度较高。多对多是最复杂的关系，很容易剪不断理还乱

在vue3 提出的 Composition API 旨在解决这些问题

### Vue 如何检测数组更新

`Vue` 内部重写数组原型链，当数组发生变化时，除了执行原生的数组方法外，还会调用 `dep.notify` 通知 `Watcher` 更新。触发数组更新的方法共7种：

- `push`
- `pop`
- `shift`
- `unshift`
- `splice`
- `sort`
- `reverse`

如果我直接根据索引去修改数组，视图会更新吗？

那为什么这几个方法可以做到数据更新视图更新呢？ Vue是怎么实现的

调用更新视图的方法 然后比如.call啥的调用一下原生的Array的方法

### vue-router的原理

`vue-router` 原理是更新视图而不重新请求页面。`vue-router` 共有3种模式：**hash模式**、**history模式**、**abstract模式**。

hash模式

`hash` 模式使用 `hashchange` 监听地址栏的 `hash` 值的变化，加载对应的页面。每次的 `hash` 值变化后依然会在浏览器留下历史记录，可以通过浏览器的前进后退按钮回到上一个页面。

history模式

`history` 模式基于History Api实现，使用 `popstate` 监听地址栏的变化。使用 `pushState` 和 `replaceState` 修改 url，而无需加载页面。但是在刷新页面时还是会向后端发起请求，需要后端配合将资源定向回前端，交由前端路由处理。

### abstract

不涉及和浏览器地址的相关记录。通过数组维护模拟浏览器的历史记录栈。

### 权限控制

### 什么是防抖，什么是节流，如何实现防抖

### v-for之后的key的作用是什么

答案：必须要用 key, 而且不能用 index 和 random，

key是vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速

在 diff 算法中用 tag 和 key来判断，是否是sameNode

可以减少渲染次数，提高渲染性能

介绍一下虚拟DOM

虚拟`DOM`本质就是用一个原生的`JavaScript`对象去描述一个`DOM`节点。是对真实`DOM`的一层抽象。

由于在浏览器中操作`DOM`是很昂贵的。频繁的操作`DOM`，会产生一定的性能问题，因此我们需要这一层抽象，在`patch`过程中尽可能地一次性将差异更新到`DOM`中，这样保证了`DOM`不会出现性能很差的情况。

另外还有很重要的一点，也是它的设计初衷，为了更好的跨平tai，比如`Node.js`就没有`DOM`,如果想实现`SSR`(服务端渲染),那么一个方式就是借助`Virtual DOM`,因为`Virtual DOM`本身是`JavaScript`对象。

`Vue2.x`中的虚拟`DOM`主要是借鉴了`snabbdom.js`，`Vue3`中借鉴`inferno.js`算法进行优化。

### computed 和 watch 的区别

1. `computed` 依赖 `data` 的改变而改变，`computed` 有返回值；`watch` 观测 `data`，执行对应的函数。
2. `computed` 有缓存功能，重复取值不会执行求值函数。
3. `computed` 依赖收集在页面渲染时触发，`watch` 依赖收集在页面渲染前触发。
4. `computed` 更新需要“渲染Watcher”的配合，`computed` 更新只是设置 `dirty`，需要页面渲染触发 `get` 重新求值

### Vue 中的 computed 是如何实现缓存的

“计算属性`Watcher`”会带有一个 `dirty` 的属性，在初始化取值完成后，会将求值结果缓存起来，并把 `dirty` 设置为 `false`。只要依赖属性不更新，`dirty` 永远为 `false`，重复取值也不会再去执行求值函数，而是直接返回缓存结果，从而实现缓存。相反，依赖属性更新会将“计算属性 `Watcher`”的 `dirty` 设置为 `true`，在页面渲染对计算属性取值时，再次触发求值函数更新计算属性。

```js
Object.defineProperty(target, key, {
    get() {
        const watcher = this._computedWatchers && this._computedWatchers[key]
        // 计算属性缓存
        if (watcher.dirty) {  
            // 计算属性求值
            watcher.evaluate()  
        }
        return watcher.value
    }
})
```

### 描述一下Event Loop

### 说一下 nextTick 的原理

在下次 dom 更新结束之后执行延迟回调。`nextTick` 主要使用了宏任务和微任务。根据执行环境分别尝试采用：

- Promise
- MutationObserver
- setImmediate
- setTimeout

`nextTick` 主要用于内部 `Watcher` 的异步更新，对外我们可以使用 `Vue.nextTick` 和 `vm.$nextTick`。在 `nextTick` 中可以获取更新完成的 dom。

### 对比 Vue3 和 Vue2.x

1. 使用 `Proxy` 代替 `Object.defineProperty`
2. 新增 `Composition API`
3. 模板允许多个根节点

### Vue3 为什么使用 Proxy 代替 Object.definedProperty

`Object.definedProperty` 只能检测到属性的获取和设置，对于新增和删除是没办法检测的。在数据初始化时，由于不知道哪些数据会被用到，`Vue` 是直接递归观测全部数据，这会导致性能多余的消耗。

`Proxy` 劫持整个对象，对象属性的增加和删除都能检测到。`Proxy` 并不能监听到内部深层的对象变化，因此 Vue 3.0 的处理方式是在 `getter` 中去递归响应式，只有真正访问到的内部对象才会变成响应式，而不是无脑递归，在很大程度上提升了性能。

Object.defineProperty有没有什么你已知的什么问题或者说缺点？

### [vue2 vue3 diff算法区别](https://co2-2020.github.io/blog/soundcode/vue/dom-diff.html#vue3-x-diff%E7%AE%97%E6%B3%95)

### Promise.then

### 平时如何去做性能优化的

### Vue 常见性能优化方式

答案：

- 合理使用v-show 和 v-if
- 合理使用computed
- v-for 时要加key，以及避免和 v-if 同时使用
- 自定义事件、DOM 事件及时销毁
- 合理使用异步组件
- 合理使用keep-alive
- data层级不要太深（因为深度监听一次性监听到底）
- 使用 vue-loader 在开发环境做模板编译（预编译）
- webpack层面的优化
- 前端通用的性能优化，如果图片懒加载
- 使用 SSR

### 有自己配过webpack吗

### webpack中如何处理图片的？

在`webpack`中有两种处理图片的`loader`：

- `file-loader`：解决`CSS`等中引入图片的路径问题；(解决通过`url`,`import/require()`等引入图片的问题)
- `url-loader`：当图片小于设置的`limit`参数值时，`url-loader`将图片进行`base64`编码(当项目中有很多图片，通过`url-loader`进行`base64`编码后会减少`http`请求数量，提高性能)，大于limit参数值，则使用`file-loader`拷贝图片并输出到编译目录中；

### 说一下回流和重绘

**回流**：

触发条件：

当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生`回流`的过程。

例如以下操作会触发回流：

1. 一个 DOM 元素的几何属性变化，常见的几何属性有`width`、`height`、`padding`、`margin`、`left`、`top`、`border` 等等, 这个很好理解。
2. 使 DOM 节点发生`增减`或者`移动`。
3. 读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。
4. 调用 `window.getComputedStyle` 方法。

回流过程：由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过`样式计算`、`生成布局树`、`建立图层树`、再到`生成绘制列表`以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。

**重绘**：

触发条件：

当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`(`repaint`)。

重绘过程：由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，所以当发生重绘的时候，会跳过`生存布局树`和`建立图层树`的阶段，直接到`生成绘制列表`，然后继续进行分块、生成位图等后面一系列操作。

**如何避免触发回流和重绘**：

1. 避免频繁使用 style，而是采用修改`class`的方式。
2. 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
3. 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的DOM操作不会引发回流和重绘
4. 使用`createDocumentFragment`进行批量的 DOM 操作。
5. 对于 resize、scroll 等进行防抖/节流处理。
6. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
7. 利用 CSS3 的`transform`、`opacity`、`filter`这些属性可以实现合成的效果，也就是`GPU`加速。

### 讲一下原型链

构造函数 原型 实例对象

### [Module和CommonJS的区别](https://zhuanlan.zhihu.com/p/71098263)

ESM静态加载 编译时确定依赖关系 但是也提供了import()的函数 可以运行时加载 是异步加载  common是运行时加载 同步加载

ESM可以tree shaking

### requestAnimationFrame

### nextTick

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。

因为宏任务耗费的时间是大于微任务的，所以先使用微任务，判断顺序如下

- `Promise`
- `MutationObserver`
- `setImmediate`
- `setTimeout`

### Vue2的初始化过程你有过了解吗，做了哪些事情

new Vue走到了vue的构造函数中：`src\core\instance\index.js`文件。

this.[_init](https://github.com/vuejs/vue/blob/a9ca2d85193e435e668ba25ace481bfb176b0c6e/src/core/instance/index.ts)(options)

然后从Mixin增加的原型方法看，initMixin(Vue)，调用的是为Vue增加的原型方法_init

```js
// src/core/instance/init.js

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
     var vm = this; 创建vm, 
     ...
     // 合并options 到 vm.$options
     vm.$options = mergeOptions(  
       resolveConstructorOptions(vm.constructor), 
       options || {},  
       vm 
     );
  }
  ...
   initLifecycle(vm); //初始生命周期
   initEvents(vm); //初始化事件
   initRender(vm); //初始render函数
   callHook(vm, 'beforeCreate'); //执行 beforeCreate生命周期钩子
   ...
   initState(vm);  //初始化data，props，methods computed，watch 
   ...
   callHook(vm, 'created');  //执行 created 生命周期钩子

   if (vm.$options.el) {
      vm.$mount(vm.$options.el);
   }
 }
```

总结

所以，从上面的函数看来，new vue所做的事情，就像一个流程图一样展开了，分别是

-   合并配置
-   初始化生命周期
-   初始化事件
-   初始化渲染
-   调用 `beforeCreate` 钩子函数
-   init injections and reactivity（这个阶段属性都已注入绑定，而且被 `$watch` 变成reactivity，但是 `$el` 还是没有生成，也就是DOM没有生成）
-   初始化state状态（初始化了data、props、computed、watcher）
-   调用created钩子函数。

在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。

### Vue SSR

[入门](https://developer.aliyun.com/article/891794#slide-1)

```markdown
与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：

*   更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。
*   更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。

Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序

服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在服务器和客户端上运行

同构
同一套vue代码在服务端执行一次在客户端再执行一次
1. 服务端执行完成渲染解决了首次加载速度慢的问题
2. 浏览器执行解决了绑定事件及恢复vue本身特性的问题


* Vue SSR是一个在SPA上进行改良的服务端渲染
* 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互
* Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA

使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例
实现ssr需要实现服务端首屏渲染和客户端激活
服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取
首屏异步获取数据，在服务端预渲染的时候就应该已经完成
切换组件通过mixin混入，在beforeMount钩子完成数据获取
```



## React

### react Fiber原理 [requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 

> 会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响

https://www.cnblogs.com/queenya/p/13572754.html 博客园



### React组件基础

### React事件机制 

> [「react进阶」一文吃透react事件系统原理](./react/事件机制.md)

### 对函数式编程的理解

这篇文章写的真的太好了，一定要读：[简明 JavaScript 函数式编程——入门篇](https://juejin.cn/post/6844903936378273799)。

总结一下： 函数式编程有两个核心概念。

- **数据不可变（无副作用）：** 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。不修改全局变量，不修改入参
- **无状态：** 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。函数的的运行结果不依赖全局变量，this 指针，IO 操作等。

纯函数带来的意义。

- **便于测试和优化**：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。
- **可缓存性**：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。
- **更少的 Bug**：使用纯函数意味着你的函数中**不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改**，这些共享状态往往是绝大多数 bug 的源头。
